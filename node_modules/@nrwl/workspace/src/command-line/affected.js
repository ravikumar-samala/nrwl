"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const runAll = require("npm-run-all");
const shared_1 = require("./shared");
const dep_graph_1 = require("./dep-graph");
const workspace_results_1 = require("./workspace-results");
const output_1 = require("./output");
const commonCommands = ['build', 'test', 'lint', 'e2e'];
function affected(parsedArgs) {
    const target = parsedArgs.target;
    const rest = [
        ...parsedArgs._.slice(1),
        ...filterNxSpecificArgs(parsedArgs)
    ];
    const workspaceResults = new workspace_results_1.WorkspaceResults(target);
    try {
        switch (target) {
            case 'apps':
                const apps = (parsedArgs.all
                    ? shared_1.getAllAppNames()
                    : shared_1.getAffectedApps(shared_1.parseFiles(parsedArgs).files))
                    .filter(app => !parsedArgs.exclude.includes(app))
                    .filter(project => !parsedArgs.onlyFailed || !workspaceResults.getResult(project));
                shared_1.printArgsWarning(parsedArgs);
                if (apps.length) {
                    output_1.output.log({
                        title: 'Affected apps:',
                        bodyLines: apps.map(app => `${output_1.output.colors.gray('-')} ${app}`)
                    });
                }
                break;
            case 'libs':
                const libs = (parsedArgs.all
                    ? shared_1.getAllLibNames()
                    : shared_1.getAffectedLibs(shared_1.parseFiles(parsedArgs).files))
                    .filter(app => !parsedArgs.exclude.includes(app))
                    .filter(project => !parsedArgs.onlyFailed || !workspaceResults.getResult(project));
                shared_1.printArgsWarning(parsedArgs);
                if (libs.length) {
                    output_1.output.log({
                        title: 'Affected libs:',
                        bodyLines: libs.map(lib => `${output_1.output.colors.gray('-')} ${lib}`)
                    });
                }
                break;
            case 'dep-graph':
                const projects = parsedArgs.all
                    ? shared_1.getProjectNames()
                    : shared_1.getAffectedProjects(shared_1.parseFiles(parsedArgs).files)
                        .filter(app => !parsedArgs.exclude.includes(app))
                        .filter(project => !parsedArgs.onlyFailed || !workspaceResults.getResult(project));
                shared_1.printArgsWarning(parsedArgs);
                dep_graph_1.generateGraph(parsedArgs, projects);
                break;
            default:
                const targetProjects = getProjects(target, parsedArgs, workspaceResults, parsedArgs.all);
                shared_1.printArgsWarning(parsedArgs);
                runCommand(target, targetProjects, parsedArgs, rest, workspaceResults);
                break;
        }
    }
    catch (e) {
        printError(e, parsedArgs.verbose);
        process.exit(1);
    }
}
exports.affected = affected;
function getProjects(target, parsedArgs, workspaceResults, all) {
    const projects = all
        ? shared_1.getAllProjectsWithTarget(target)
        : shared_1.getAffectedProjectsWithTarget(target)(shared_1.parseFiles(parsedArgs).files);
    return projects
        .filter(project => !parsedArgs.exclude.includes(project))
        .filter(project => !parsedArgs.onlyFailed || !workspaceResults.getResult(project));
}
function printError(e, verbose) {
    const bodyLines = [e.message];
    if (verbose && e.stack) {
        bodyLines.push('');
        bodyLines.push(e.stack);
    }
    output_1.output.error({
        title: 'There was a critical error when running your command',
        bodyLines
    });
}
function runCommand(targetName, projects, parsedArgs, args, workspaceResults) {
    return __awaiter(this, void 0, void 0, function* () {
        if (projects.length <= 0) {
            output_1.output.logSingleLine(`No affected projects to run target "${targetName}" on`);
            return;
        }
        const cli = shared_1.cliCommand();
        const bodyLines = projects.map(project => `${output_1.output.colors.gray('-')} ${project}`);
        if (args.length > 0) {
            bodyLines.push('');
            bodyLines.push(`${output_1.output.colors.gray('With flags:')} ${output_1.output.bold(args.join(' '))}`);
        }
        output_1.output.log({
            title: `${output_1.output.colors.gray('Running target')} ${targetName} ${output_1.output.colors.gray('for projects:')}`,
            bodyLines
        });
        output_1.output.addVerticalSeparator();
        const workspaceJson = shared_1.readWorkspaceJson();
        const projectMetadata = new Map();
        projects.forEach(project => {
            projectMetadata.set(project, workspaceJson.projects[project]);
        });
        // Make sure the `package.json` has the `nx: "nx"` command needed by `npm-run-all`
        const packageJson = JSON.parse(fs.readFileSync('./package.json').toString('utf-8'));
        if (!packageJson.scripts || !packageJson.scripts[cli]) {
            output_1.output.error({
                title: `The "scripts" section of your 'package.json' must contain "${cli}": "${cli}"`,
                bodyLines: [
                    output_1.output.colors.gray('...'),
                    ' "scripts": {',
                    output_1.output.colors.gray('  ...'),
                    `   "${cli}": "${cli}"`,
                    output_1.output.colors.gray('  ...'),
                    ' }',
                    output_1.output.colors.gray('...')
                ]
            });
            return process.exit(1);
        }
        try {
            yield runAll(projects.map(proj => {
                return commonCommands.includes(targetName)
                    ? `${cli} -- ${targetName} ${proj} ${transformArgs(args, proj, projectMetadata.get(proj)).join(' ')} `
                    : `${cli} -- run ${proj}:${targetName} ${transformArgs(args, proj, projectMetadata.get(proj)).join(' ')} `;
            }), {
                parallel: parsedArgs.parallel || false,
                maxParallel: parsedArgs.maxParallel || 1,
                continueOnError: true,
                stdin: process.stdin,
                stdout: process.stdout,
                stderr: process.stderr
            });
            projects.forEach(project => {
                workspaceResults.success(project);
            });
        }
        catch (e) {
            e.results.forEach((result, i) => {
                if (result.code === 0) {
                    workspaceResults.success(projects[i]);
                }
                else {
                    workspaceResults.fail(projects[i]);
                }
            });
        }
        finally {
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
        }
        workspaceResults.saveResults();
        workspaceResults.printResults(parsedArgs.onlyFailed, `Running target "${targetName}" for affected projects succeeded`, `Running target "${targetName}" for affected projects failed`);
        if (workspaceResults.hasFailure) {
            process.exit(1);
        }
    });
}
function transformArgs(args, projectName, projectMetadata) {
    return args.map(arg => {
        const regex = /{project\.([^}]+)}/g;
        return arg.replace(regex, (_, group) => {
            if (group.includes('.')) {
                throw new Error('Only top-level properties can be interpolated');
            }
            if (group === 'name') {
                return projectName;
            }
            return projectMetadata[group];
        });
    });
}
function filterNxSpecificArgs(parsedArgs) {
    const filteredArgs = Object.assign({}, parsedArgs);
    // Delete Nx arguments from parsed Args
    nxSpecificFlags.forEach(flag => {
        delete filteredArgs[flag];
    });
    // These would be arguments such as app2 in  --app app1 app2 which the CLI does not accept
    delete filteredArgs._;
    // Also remove the node path
    delete filteredArgs.$0;
    // Re-serialize into a list of args
    return Object.keys(filteredArgs).map(filteredArg => {
        if (!Array.isArray(filteredArgs[filteredArg])) {
            filteredArgs[filteredArg] = [filteredArgs[filteredArg]];
        }
        return filteredArgs[filteredArg]
            .map(value => {
            return `--${filteredArg}=${value}`;
        })
            .join(' ');
    });
}
/**
 * These options are only for getting an array with properties of AffectedOptions.
 *
 * @remark They are not defaults or useful for anything else
 */
const dummyOptions = {
    target: '',
    parallel: false,
    maxParallel: 3,
    'max-parallel': false,
    onlyFailed: false,
    'only-failed': false,
    untracked: false,
    uncommitted: false,
    help: false,
    version: false,
    quiet: false,
    all: false,
    base: 'base',
    head: 'head',
    exclude: ['exclude'],
    files: [''],
    verbose: false
};
const nxSpecificFlags = Object.keys(dummyOptions);
