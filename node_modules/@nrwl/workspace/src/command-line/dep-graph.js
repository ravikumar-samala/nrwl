"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fileutils_1 = require("../utils/fileutils");
const graphviz = require("graphviz");
const opn = require("opn");
const affected_apps_1 = require("./affected-apps");
const shared_1 = require("./shared");
const path = require("path");
const tmp_1 = require("tmp");
const deps_calculator_1 = require("./deps-calculator");
const viz = require('viz.js'); // typings are incorrect in viz.js library - need to use `require`
var NodeEdgeVariant;
(function (NodeEdgeVariant) {
    NodeEdgeVariant["default"] = "default";
    NodeEdgeVariant["highlighted"] = "highlighted";
})(NodeEdgeVariant = exports.NodeEdgeVariant || (exports.NodeEdgeVariant = {}));
var OutputType;
(function (OutputType) {
    OutputType["json"] = "json";
    OutputType["html"] = "html";
    OutputType["dot"] = "dot";
    OutputType["svg"] = "svg";
})(OutputType = exports.OutputType || (exports.OutputType = {}));
const defaultConfig = {
    isFilePresent: false,
    filename: undefined,
    type: OutputType.html,
    shouldOpen: true
};
exports.graphvizConfig = {
    graph: [
        {
            attr: 'overlap',
            value: false
        },
        {
            attr: 'pad',
            value: 0.111
        }
    ],
    nodes: {
        [affected_apps_1.ProjectType.e2e]: {
            [NodeEdgeVariant.default]: {
                fontname: 'Arial',
                fontsize: 14,
                shape: 'box'
            },
            [NodeEdgeVariant.highlighted]: {
                fontname: 'Arial',
                fontsize: 14,
                shape: 'box',
                color: '#FF0033'
            }
        },
        [affected_apps_1.ProjectType.app]: {
            [NodeEdgeVariant.default]: {
                fontname: 'Arial',
                fontsize: 14,
                shape: 'box'
            },
            [NodeEdgeVariant.highlighted]: {
                fontname: 'Arial',
                fontsize: 14,
                shape: 'box',
                color: '#FF0033'
            }
        },
        [affected_apps_1.ProjectType.lib]: {
            [NodeEdgeVariant.default]: {
                fontname: 'Arial',
                fontsize: 14,
                style: 'filled',
                fillcolor: '#EFEFEF'
            },
            [NodeEdgeVariant.highlighted]: {
                fontname: 'Arial',
                fontsize: 14,
                style: 'filled',
                fillcolor: '#EFEFEF',
                color: '#FF0033'
            }
        }
    },
    edges: {
        [deps_calculator_1.DependencyType.es6Import]: {
            [NodeEdgeVariant.default]: {
                color: '#757575'
            },
            [NodeEdgeVariant.highlighted]: {
                color: '#FF0033'
            }
        },
        [deps_calculator_1.DependencyType.loadChildren]: {
            [NodeEdgeVariant.default]: {
                color: '#757575',
                style: 'dotted'
            },
            [NodeEdgeVariant.highlighted]: {
                color: '#FF0033',
                style: 'dotted'
            }
        },
        [deps_calculator_1.DependencyType.implicit]: {
            [NodeEdgeVariant.default]: {
                color: '#000000',
                style: 'bold'
            },
            [NodeEdgeVariant.highlighted]: {
                color: '#FF0033',
                style: 'bold'
            }
        }
    }
};
function mapProjectNodes(projects) {
    return projects.reduce((m, proj) => (Object.assign({}, m, { [proj.name]: proj })), {});
}
function getVariant(map, key) {
    return map[key] ? NodeEdgeVariant.highlighted : NodeEdgeVariant.default;
}
function getNodeProps(config, projectNode, criticalPath) {
    const nodeProps = config[projectNode.type];
    return nodeProps[getVariant(criticalPath, projectNode.name)];
}
function getEdgeProps(config, depType, child, criticalPath) {
    const edgeProps = config[depType];
    return edgeProps[getVariant(criticalPath, child)];
}
function createGraphviz(config, deps, projects, criticalPath) {
    const projectMap = mapProjectNodes(projects);
    const g = graphviz.digraph('G');
    config.graph.forEach(({ attr, value }) => g.set(attr, value));
    Object.keys(deps)
        .sort() // sorting helps with testing
        .forEach(key => {
        const projectNode = projectMap[key];
        const dependencies = deps[key];
        g.addNode(key, getNodeProps(config.nodes, projectNode, criticalPath));
        if (dependencies.length > 0) {
            dependencies.forEach((dep) => {
                g.addNode(dep.projectName, getNodeProps(config.nodes, projectMap[dep.projectName], criticalPath)); // child node
                g.addEdge(key, dep.projectName, getEdgeProps(config.edges, dep.type, dep.projectName, criticalPath));
            });
        }
    });
    return g.to_dot();
}
exports.createGraphviz = createGraphviz;
function handleOutput({ data, shouldOpen, filename }) {
    if (shouldOpen) {
        const tmpFilename = `${tmp_1.tmpNameSync()}.html`;
        fileutils_1.writeToFile(tmpFilename, data);
        opn(tmpFilename, {
            wait: false
        });
    }
    else {
        fileutils_1.writeToFile(filename, data);
    }
}
function applyHTMLTemplate(svg) {
    return `<!DOCTYPE html>
  <html>
    <head><title></title></head>
    <body>${svg}</body>
  </html>
  `;
}
function generateGraphJson(projects, criticalPath) {
    const nxJson = shared_1.readNxJson();
    const npmScope = nxJson.npmScope;
    // fetch all apps and libs
    const deps = deps_calculator_1.readDependencies(npmScope, projects);
    return {
        deps,
        criticalPath
    };
}
function getDot(projects, json) {
    return createGraphviz(exports.graphvizConfig, json.deps, projects, json.criticalPath.reduce((m, proj) => (Object.assign({}, m, { [proj]: true })), {}));
}
function getConfigFromUserInput(cmdOpts) {
    const filename = cmdOpts.file;
    const output = cmdOpts.output;
    if (filename && output) {
        throw new Error('Received both filename as well as output type. Please only specify one of the options.');
    }
    const extension = !!filename
        ? path.extname(filename).substring(1)
        : output || OutputType.html;
    return {
        isFilePresent: !output,
        type: extension,
        output: output,
        shouldOpen: !output && !filename,
        filename
    };
}
function extractDataFromJson(projects, json, type) {
    switch (type) {
        case OutputType.json:
            return JSON.stringify(json, null, 2);
        case OutputType.dot:
            return getDot(projects, json);
        case OutputType.html:
            return applyHTMLTemplate(viz(getDot(projects, json)));
        case OutputType.svg:
            return viz(getDot(projects, json));
        default:
            throw new Error('Unrecognized file extension. Supported extensions are "json", "html", and "dot"');
    }
}
function generateGraph(args, criticalPath) {
    const workspaceJson = shared_1.readWorkspaceJson();
    const nxJson = shared_1.readNxJson();
    const projects = shared_1.getProjectNodes(workspaceJson, nxJson);
    const json = generateGraphJson(projects, criticalPath || []);
    const config = Object.assign({}, defaultConfig, getConfigFromUserInput(args));
    handleOutput({
        data: extractDataFromJson(projects, json, config.type),
        filename: config.filename,
        shouldOpen: config.shouldOpen
    });
}
exports.generateGraph = generateGraph;
