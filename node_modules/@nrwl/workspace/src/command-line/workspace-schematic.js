"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const node_1 = require("@angular-devkit/core/node");
const schematics_1 = require("@angular-devkit/schematics");
const tools_1 = require("@angular-devkit/schematics/tools");
const child_process_1 = require("child_process");
const fs = require("fs");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const inquirer = require("inquirer");
const path = require("path");
const yargsParser = require("yargs-parser");
const fileutils_1 = require("../utils/fileutils");
const app_root_1 = require("../utils/app-root");
const output_1 = require("./output");
const os_1 = require("os");
const rootDirectory = app_root_1.appRootPath;
function workspaceSchematic(args) {
    const parsedArgs = parseOptions(args);
    const logger = node_1.createConsoleLogger(parsedArgs.verbose, process.stdout, process.stderr);
    const outDir = compileTools();
    if (parsedArgs.listSchematics) {
        return listSchematics(path.join(outDir, 'workspace-schematics.json'), logger);
    }
    const schematicName = args[0];
    const workflow = createWorkflow(parsedArgs.dryRun);
    executeSchematic(schematicName, parsedArgs, workflow, outDir, logger);
}
exports.workspaceSchematic = workspaceSchematic;
// compile tools
function compileTools() {
    const toolsOutDir = getToolsOutDir();
    fs_extra_1.removeSync(toolsOutDir);
    compileToolsDir(toolsOutDir);
    const schematicsOutDir = path.join(toolsOutDir, 'schematics');
    const collectionData = constructCollection();
    saveCollection(schematicsOutDir, collectionData);
    return schematicsOutDir;
}
function getToolsOutDir() {
    return path.resolve(rootDirectory, 'tools', JSON.parse(fs_1.readFileSync(path.join(rootDirectory, 'tools', 'tsconfig.tools.json'), 'UTF-8')).compilerOptions.outDir);
}
function compileToolsDir(outDir) {
    fs_extra_1.copySync(path.join(rootDirectory, 'tools'), outDir);
    const tsc = os_1.platform() === 'win32'
        ? `.\\node_modules\\.bin\\tsc`
        : `./node_modules/.bin/tsc`;
    try {
        child_process_1.execSync(`${tsc} -p tools/tsconfig.tools.json`, {
            stdio: 'inherit',
            cwd: rootDirectory
        });
    }
    catch (e) {
        process.exit(1);
    }
}
function constructCollection() {
    const schematics = {};
    fs.readdirSync(schematicsDir()).forEach(c => {
        const childDir = path.join(schematicsDir(), c);
        if (exists(path.join(childDir, 'schema.json'))) {
            schematics[c] = {
                factory: `./${c}`,
                schema: `./${path.join(c, 'schema.json')}`,
                description: `Schematic ${c}`
            };
        }
    });
    return {
        name: 'workspace-schematics',
        version: '1.0',
        schematics
    };
}
function saveCollection(dir, collection) {
    fs_1.writeFileSync(path.join(dir, 'workspace-schematics.json'), JSON.stringify(collection));
}
function schematicsDir() {
    return path.join('tools', 'schematics');
}
function createWorkflow(dryRun) {
    const root = core_1.normalize(rootDirectory);
    const host = new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root);
    return new tools_1.NodeWorkflow(host, {
        packageManager: detectPackageManager(),
        root,
        dryRun,
        registry: new core_1.schema.CoreSchemaRegistry(schematics_1.formats.standardFormats)
    });
}
function detectPackageManager() {
    try {
        const output = child_process_1.execSync(`nx config cli.packageManager`, {
            stdio: ['ignore', 'pipe', 'ignore']
        })
            .toString()
            .trim()
            .split('\n');
        return output[output.length - 1].trim();
    }
    catch (e) {
        return fileutils_1.fileExists('yarn.lock')
            ? 'yarn'
            : fileutils_1.fileExists('pnpm-lock.yaml')
                ? 'pnpm'
                : 'npm';
    }
}
function listSchematics(collectionName, logger) {
    try {
        const engineHost = new tools_1.NodeModulesEngineHost();
        const engine = new schematics_1.SchematicEngine(engineHost);
        const collection = engine.createCollection(collectionName);
        logger.info(engine.listSchematicNames(collection).join('\n'));
    }
    catch (error) {
        logger.fatal(error.message);
        return 1;
    }
    return 0;
}
function createPromptProvider() {
    return (definitions) => {
        const questions = definitions.map(definition => {
            const question = {
                name: definition.id,
                message: definition.message,
                default: definition.default
            };
            const validator = definition.validator;
            if (validator) {
                question.validate = input => validator(input);
            }
            switch (definition.type) {
                case 'confirmation':
                    return Object.assign({}, question, { type: 'confirm' });
                case 'list':
                    return Object.assign({}, question, { type: !!definition.multiselect ? 'checkbox' : 'list', choices: definition.items &&
                            definition.items.map(item => {
                                if (typeof item == 'string') {
                                    return item;
                                }
                                else {
                                    return {
                                        name: item.label,
                                        value: item.value
                                    };
                                }
                            }) });
                default:
                    return Object.assign({}, question, { type: definition.type });
            }
        });
        return inquirer.prompt(questions);
    };
}
// execute schematic
function executeSchematic(schematicName, options, workflow, outDir, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        output_1.output.logSingleLine(`${output_1.output.colors.gray(`Executing your local schematic`)}: ${schematicName}`);
        let nothingDone = true;
        workflow.reporter.subscribe((event) => {
            nothingDone = false;
            const eventPath = event.path.startsWith('/')
                ? event.path.substr(1)
                : event.path;
            switch (event.kind) {
                case 'error':
                    const desc = event.description == 'alreadyExist'
                        ? 'already exists'
                        : 'does not exist.';
                    console.error(`error! ${eventPath} ${desc}.`);
                    break;
                case 'update':
                    console.log(`update ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'create':
                    console.log(`create ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'delete':
                    console.log(`delete ${eventPath}`);
                    break;
                case 'rename':
                    const eventToPath = event.to.startsWith('/')
                        ? event.to.substr(1)
                        : event.to;
                    console.log(`rename ${eventPath} => ${eventToPath}`);
                    break;
            }
        });
        const args = options._.slice(1);
        workflow.registry.addSmartDefaultProvider('argv', (schema) => {
            if ('index' in schema) {
                return args[+schema.index];
            }
            else {
                return args;
            }
        });
        delete options._;
        if (options.defaults) {
            workflow.registry.addPreTransform(core_1.schema.transforms.addUndefinedDefaults);
        }
        else {
            workflow.registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        }
        workflow.engineHost.registerOptionsTransform(tools_1.validateOptionsWithSchema(workflow.registry));
        // Add support for interactive prompts
        if (options.interactive) {
            workflow.registry.usePromptProvider(createPromptProvider());
        }
        try {
            yield workflow
                .execute({
                collection: path.join(outDir, 'workspace-schematics.json'),
                schematic: schematicName,
                options: options,
                logger: logger
            })
                .toPromise();
            if (nothingDone) {
                logger.info('Nothing to be done.');
            }
        }
        catch (err) {
            if (err instanceof schematics_1.UnsuccessfulWorkflowExecution) {
                // "See above" because we already printed the error.
                logger.fatal('The Schematic workflow failed. See above.');
            }
            else {
                logger.fatal(err.stack || err.message);
            }
        }
    });
}
function parseOptions(args) {
    return yargsParser(args, {
        boolean: ['dryRun', 'listSchematics', 'interactive'],
        alias: {
            dryRun: ['d'],
            listSchematics: ['l']
        },
        default: {
            interactive: true
        }
    });
}
function exists(file) {
    try {
        return !!fs.statSync(file);
    }
    catch (e) {
        return false;
    }
}
