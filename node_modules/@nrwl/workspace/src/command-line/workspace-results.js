"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const fileutils_1 = require("../utils/fileutils");
const fs_1 = require("fs");
const output_1 = require("./output");
const RESULTS_FILE = 'dist/.nx-results';
class WorkspaceResults {
    constructor(command) {
        this.command = command;
        this.commandResults = {
            command: this.command,
            results: {}
        };
        const resultsExists = fs.existsSync(RESULTS_FILE);
        this.startedWithFailedProjects = false;
        if (resultsExists) {
            try {
                const commandResults = fileutils_1.readJsonFile(RESULTS_FILE);
                this.startedWithFailedProjects = commandResults.command === command;
                if (this.startedWithFailedProjects) {
                    this.commandResults = commandResults;
                }
            }
            catch (_a) {
                /**
                 * If we got here it is likely that RESULTS_FILE is not valid JSON.
                 * It is safe to continue, and it does not make much sense to give the
                 * user feedback as the file will be updated automatically.
                 */
            }
        }
    }
    get failedProjects() {
        return Object.entries(this.commandResults.results)
            .filter(([_, result]) => !result)
            .map(([project]) => project);
    }
    get hasFailure() {
        return Object.values(this.commandResults.results).some(result => !result);
    }
    getResult(projectName) {
        return this.commandResults.results[projectName];
    }
    fail(projectName) {
        this.setResult(projectName, false);
    }
    success(projectName) {
        this.setResult(projectName, true);
    }
    saveResults() {
        if (Object.values(this.commandResults.results).includes(false)) {
            fileutils_1.writeJsonFile(RESULTS_FILE, this.commandResults);
        }
        else if (fs.existsSync(RESULTS_FILE)) {
            fs_1.unlinkSync(RESULTS_FILE);
        }
    }
    printResults(onlyFailed, successMessage, failureMessage) {
        /**
         * Leave a bit of breathing room between the process output
         * and our formatted results.
         */
        output_1.output.addNewline();
        output_1.output.addVerticalSeparator();
        if (this.failedProjects.length === 0) {
            output_1.output.success({
                title: successMessage
            });
            if (onlyFailed && this.startedWithFailedProjects) {
                output_1.output.warn({
                    title: `Only affected projects ${output_1.output.underline('which had previously failed')} were run`,
                    bodyLines: [
                        `You should verify by running ${output_1.output.underline('without')} ${output_1.output.bold('--only-failed')}`
                    ]
                });
            }
            return;
        }
        const bodyLines = [
            output_1.output.colors.gray('Failed projects:'),
            '',
            ...this.failedProjects.map(project => `${output_1.output.colors.gray('-')} ${project}`)
        ];
        if (!onlyFailed && !this.startedWithFailedProjects) {
            bodyLines.push('');
            bodyLines.push(`${output_1.output.colors.gray('You can isolate the above projects by passing:')} ${output_1.output.bold('--only-failed')}`);
        }
        output_1.output.error({
            title: failureMessage,
            bodyLines
        });
    }
    setResult(projectName, result) {
        this.commandResults.results[projectName] = result;
    }
}
exports.WorkspaceResults = WorkspaceResults;
