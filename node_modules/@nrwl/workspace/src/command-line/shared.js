"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = require("fs");
const path = require("path");
const app_root_1 = require("../utils/app-root");
const fileutils_1 = require("../utils/fileutils");
const affected_apps_1 = require("./affected-apps");
const deps_calculator_1 = require("./deps-calculator");
const touched_1 = require("./touched");
const output_1 = require("./output");
const ignore = require('ignore');
function readFileIfExisting(path) {
    return fs.existsSync(path) ? fs.readFileSync(path, 'UTF-8').toString() : '';
}
function getIgnoredGlobs() {
    const ig = ignore();
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.gitignore`));
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.nxignore`));
    return ig;
}
function printArgsWarning(options) {
    const { files, uncommitted, untracked, base, head, all } = options;
    if (!files &&
        !uncommitted &&
        !untracked &&
        !base &&
        !head &&
        !all &&
        options._.length < 2) {
        output_1.output.note({
            title: `Affected criteria defaulted to --base=${output_1.output.bold('master')} --head=${output_1.output.bold('HEAD')}`
        });
    }
    if (all) {
        output_1.output.warn({
            title: `Running affected:* commands with --all can result in very slow builds.`,
            bodyLines: [
                output_1.output.bold('--all') +
                    ' is not meant to be used for any sizable project or to be used in CI.',
                '',
                output_1.output.colors.gray('Learn more about checking only what is affected: ') + 'https://nx.dev/guides/monorepo-affected.'
            ]
        });
    }
}
exports.printArgsWarning = printArgsWarning;
function parseFiles(options) {
    const { files, uncommitted, untracked, base, head } = options;
    if (files) {
        return {
            files
        };
    }
    else if (uncommitted) {
        return {
            files: getUncommittedFiles()
        };
    }
    else if (untracked) {
        return {
            files: getUntrackedFiles()
        };
    }
    else if (base && head) {
        return {
            files: getFilesUsingBaseAndHead(base, head)
        };
    }
    else if (base) {
        return {
            files: Array.from(new Set([
                ...getFilesUsingBaseAndHead(base, 'HEAD'),
                ...getUncommittedFiles(),
                ...getUntrackedFiles()
            ]))
        };
    }
    else if (options._.length >= 2) {
        return {
            files: getFilesFromShash(options._[1], options._[2])
        };
    }
    else {
        return {
            files: Array.from(new Set([
                ...getFilesUsingBaseAndHead('master', 'HEAD'),
                ...getUncommittedFiles(),
                ...getUntrackedFiles()
            ]))
        };
    }
}
exports.parseFiles = parseFiles;
function getUncommittedFiles() {
    return parseGitOutput(`git diff --name-only HEAD .`);
}
function getUntrackedFiles() {
    return parseGitOutput(`git ls-files --others --exclude-standard`);
}
function getFilesUsingBaseAndHead(base, head) {
    const mergeBase = child_process_1.execSync(`git merge-base ${base} ${head}`)
        .toString()
        .trim();
    return parseGitOutput(`git diff --name-only ${mergeBase} ${head}`);
}
function getFilesFromShash(sha1, sha2) {
    return parseGitOutput(`git diff --name-only ${sha1} ${sha2}`);
}
function parseGitOutput(command) {
    return child_process_1.execSync(command)
        .toString('utf-8')
        .split('\n')
        .map(a => a.trim())
        .filter(a => a.length > 0);
}
function getFileLevelImplicitDependencies(projects, nxJson) {
    if (!nxJson.implicitDependencies) {
        return {};
    }
    Object.entries(nxJson.implicitDependencies).forEach(([key, value]) => {
        if (value === '*') {
            nxJson.implicitDependencies[key] = projects.map(p => p.name);
        }
    });
    return nxJson.implicitDependencies;
}
function getProjectLevelImplicitDependencies(projects) {
    const implicitDependencies = projects.reduce((memo, project) => {
        project.implicitDependencies.forEach(dep => {
            if (memo[dep]) {
                memo[dep].add(project.name);
            }
            else {
                memo[dep] = new Set([project.name]);
            }
        });
        return memo;
    }, {});
    return Object.entries(implicitDependencies).reduce((memo, [key, val]) => {
        memo[key] = Array.from(val);
        return memo;
    }, {});
}
function detectAndSetInvalidProjectValues(map, sourceName, desiredProjectNames, validProjects) {
    const invalidProjects = desiredProjectNames.filter(projectName => !validProjects[projectName]);
    if (invalidProjects.length > 0) {
        map.set(sourceName, invalidProjects);
    }
}
function getImplicitDependencies(projects, workspaceJson, nxJson) {
    assertWorkspaceValidity(workspaceJson, nxJson);
    const implicitFileDeps = getFileLevelImplicitDependencies(projects, nxJson);
    const implicitProjectDeps = getProjectLevelImplicitDependencies(projects);
    return {
        files: implicitFileDeps,
        projects: implicitProjectDeps
    };
}
exports.getImplicitDependencies = getImplicitDependencies;
function assertWorkspaceValidity(workspaceJson, nxJson) {
    const workspaceJsonProjects = Object.keys(workspaceJson.projects);
    const nxJsonProjects = Object.keys(nxJson.projects);
    if (minus(workspaceJsonProjects, nxJsonProjects).length > 0) {
        throw new Error(`${workspaceFileName()} and nx.json are out of sync. The following projects are missing in nx.json: ${minus(workspaceJsonProjects, nxJsonProjects).join(', ')}`);
    }
    if (minus(nxJsonProjects, workspaceJsonProjects).length > 0) {
        throw new Error(`${workspaceFileName()} and nx.json are out of sync. The following projects are missing in ${workspaceFileName()}: ${minus(nxJsonProjects, workspaceJsonProjects).join(', ')}`);
    }
    const projects = Object.assign({}, workspaceJson.projects, nxJson.projects);
    const invalidImplicitDependencies = new Map();
    Object.entries(nxJson.implicitDependencies || {})
        .filter(([_, val]) => val !== '*') // These are valid since it is calculated
        .reduce((map, [filename, projectNames]) => {
        detectAndSetInvalidProjectValues(map, filename, projectNames, projects);
        return map;
    }, invalidImplicitDependencies);
    nxJsonProjects
        .filter(nxJsonProjectName => {
        const project = nxJson.projects[nxJsonProjectName];
        return !!project.implicitDependencies;
    })
        .reduce((map, nxJsonProjectName) => {
        const project = nxJson.projects[nxJsonProjectName];
        detectAndSetInvalidProjectValues(map, nxJsonProjectName, project.implicitDependencies, projects);
        return map;
    }, invalidImplicitDependencies);
    if (invalidImplicitDependencies.size === 0) {
        return;
    }
    let message = `The following implicitDependencies specified in nx.json are invalid:
  `;
    invalidImplicitDependencies.forEach((projectNames, key) => {
        const str = `  ${key}
    ${projectNames.map(projectName => `    ${projectName}`).join('\n')}`;
        message += str;
    });
    throw new Error(message);
}
exports.assertWorkspaceValidity = assertWorkspaceValidity;
function getProjectNodes(workspaceJson, nxJson) {
    assertWorkspaceValidity(workspaceJson, nxJson);
    const workspaceJsonProjects = Object.keys(workspaceJson.projects);
    return workspaceJsonProjects.map(key => {
        const p = workspaceJson.projects[key];
        const tags = nxJson.projects[key].tags;
        const projectType = p.projectType === 'application'
            ? key.endsWith('-e2e')
                ? affected_apps_1.ProjectType.e2e
                : affected_apps_1.ProjectType.app
            : affected_apps_1.ProjectType.lib;
        let implicitDependencies = nxJson.projects[key].implicitDependencies || [];
        if (projectType === affected_apps_1.ProjectType.e2e && implicitDependencies.length === 0) {
            implicitDependencies = [key.replace(/-e2e$/, '')];
        }
        const filesWithMTimes = allFilesInDir(`${app_root_1.appRootPath}/${p.root}`);
        const fileMTimes = {};
        filesWithMTimes.forEach(f => {
            fileMTimes[f.file] = f.mtime;
        });
        return {
            name: key,
            root: p.root,
            type: projectType,
            tags,
            architect: p.architect || {},
            files: filesWithMTimes.map(f => f.file),
            implicitDependencies,
            fileMTimes
        };
    });
}
exports.getProjectNodes = getProjectNodes;
function minus(a, b) {
    const res = [];
    a.forEach(aa => {
        if (!b.find(bb => bb === aa)) {
            res.push(aa);
        }
    });
    return res;
}
function cliCommand() {
    return workspaceFileName() === 'angular.json' ? 'ng' : 'nx';
}
exports.cliCommand = cliCommand;
function readWorkspaceJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/${workspaceFileName()}`);
}
exports.readWorkspaceJson = readWorkspaceJson;
function workspaceFileName() {
    const packageJson = readPackageJson();
    if (packageJson.devDependencies['@angular/cli'] ||
        packageJson.dependencies['@angular/cli']) {
        return 'angular.json';
    }
    else {
        return 'workspace.json';
    }
}
exports.workspaceFileName = workspaceFileName;
function readPackageJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/package.json`);
}
exports.readPackageJson = readPackageJson;
function readNxJson() {
    const config = fileutils_1.readJsonFile(`${app_root_1.appRootPath}/nx.json`);
    if (!config.npmScope) {
        throw new Error(`nx.json must define the npmScope property.`);
    }
    return config;
}
exports.readNxJson = readNxJson;
exports.getAffected = (affectedNamesFetcher) => (touchedFiles) => {
    const workspaceJson = readWorkspaceJson();
    const nxJson = readNxJson();
    const projects = getProjectNodes(workspaceJson, nxJson);
    const implicitDeps = getImplicitDependencies(projects, workspaceJson, nxJson);
    const dependencies = deps_calculator_1.readDependencies(nxJson.npmScope, projects);
    const sortedProjects = topologicallySortProjects(projects, dependencies);
    const tp = touched_1.touchedProjects(implicitDeps, projects, touchedFiles);
    return affectedNamesFetcher(sortedProjects, dependencies, tp);
};
function getAffectedProjectsWithTarget(target) {
    return exports.getAffected(affected_apps_1.affectedProjectNamesWithTarget(target));
}
exports.getAffectedProjectsWithTarget = getAffectedProjectsWithTarget;
exports.getAffectedApps = exports.getAffected(affected_apps_1.affectedAppNames);
exports.getAffectedProjects = exports.getAffected(affected_apps_1.affectedProjectNames);
exports.getAffectedLibs = exports.getAffected(affected_apps_1.affectedLibNames);
function getAllAppNames() {
    return getProjectNames(p => p.type === affected_apps_1.ProjectType.app);
}
exports.getAllAppNames = getAllAppNames;
function getAllLibNames() {
    return getProjectNames(p => p.type === affected_apps_1.ProjectType.lib);
}
exports.getAllLibNames = getAllLibNames;
function getAllProjectNamesWithTarget(target) {
    return getProjectNames(p => p.architect[target]);
}
exports.getAllProjectNamesWithTarget = getAllProjectNamesWithTarget;
function getAllProjectsWithTarget(target) {
    const workspaceJson = readWorkspaceJson();
    const nxJson = readNxJson();
    const projects = getProjectNodes(workspaceJson, nxJson);
    const dependencies = deps_calculator_1.readDependencies(nxJson.npmScope, projects);
    const sortedProjects = topologicallySortProjects(projects, dependencies);
    return sortedProjects.filter(p => p.architect[target]).map(p => p.name);
}
exports.getAllProjectsWithTarget = getAllProjectsWithTarget;
function getProjectNames(predicate) {
    let projects = getProjectNodes(readWorkspaceJson(), readNxJson());
    if (predicate) {
        projects = projects.filter(predicate);
    }
    return projects.map(p => p.name);
}
exports.getProjectNames = getProjectNames;
function getProjectRoots(projectNames) {
    const { projects } = readWorkspaceJson();
    return projectNames.map(name => projects[name].root);
}
exports.getProjectRoots = getProjectRoots;
function allFilesInDir(dirName) {
    const ignoredGlobs = getIgnoredGlobs();
    if (ignoredGlobs.ignores(path.relative(app_root_1.appRootPath, dirName))) {
        return [];
    }
    let res = [];
    try {
        fs.readdirSync(dirName).forEach(c => {
            const child = path.join(dirName, c);
            if (ignoredGlobs.ignores(path.relative(app_root_1.appRootPath, child))) {
                return;
            }
            try {
                const s = fs.statSync(child);
                if (!s.isDirectory()) {
                    // add starting with "apps/myapp/..." or "libs/mylib/..."
                    res.push({
                        file: normalizePath(path.relative(app_root_1.appRootPath, child)),
                        mtime: s.mtimeMs
                    });
                }
                else if (s.isDirectory()) {
                    res = [...res, ...allFilesInDir(child)];
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    return res;
}
exports.allFilesInDir = allFilesInDir;
function lastModifiedAmongProjectFiles(projects) {
    return Math.max(...[
        ...projects.map(project => getProjectMTime(project)),
        mtime(`${app_root_1.appRootPath}/${workspaceFileName()}`),
        mtime(`${app_root_1.appRootPath}/nx.json`),
        mtime(`${app_root_1.appRootPath}/tslint.json`),
        mtime(`${app_root_1.appRootPath}/package.json`)
    ]);
}
exports.lastModifiedAmongProjectFiles = lastModifiedAmongProjectFiles;
function getProjectMTime(project) {
    return Math.max(...Object.values(project.fileMTimes));
}
exports.getProjectMTime = getProjectMTime;
/**
 * Returns the time when file was last modified
 * Returns -Infinity for a non-existent file
 */
function mtime(filePath) {
    if (!fs.existsSync(filePath)) {
        return -Infinity;
    }
    return fs.statSync(filePath).mtimeMs;
}
exports.mtime = mtime;
function normalizePath(file) {
    return file.split(path.sep).join('/');
}
function normalizedProjectRoot(p) {
    return p.root
        .split('/')
        .filter(v => !!v)
        .slice(1)
        .join('/');
}
exports.normalizedProjectRoot = normalizedProjectRoot;
function topologicallySortProjects(projects, deps) {
    const temporary = {};
    const marked = {};
    const res = [];
    while (Object.keys(marked).length !== projects.length) {
        visit(projects.find(p => !marked[p.name]));
    }
    function visit(n) {
        if (marked[n.name])
            return;
        if (temporary[n.name])
            return;
        temporary[n.name] = true;
        deps[n.name].forEach(e => {
            visit(projects.find(pp => pp.name === e.projectName));
        });
        marked[n.name] = true;
        res.push(n);
    }
    return res;
}
