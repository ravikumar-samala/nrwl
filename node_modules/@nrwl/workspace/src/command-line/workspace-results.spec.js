"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const workspace_results_1 = require("./workspace-results");
const fileutils_1 = require("../utils/fileutils");
const output_1 = require("./output");
describe('WorkspacesResults', () => {
    let results;
    beforeEach(() => {
        results = new workspace_results_1.WorkspaceResults('test');
    });
    it('should be instantiable', () => {
        expect(results).toBeTruthy();
    });
    it('should default with no failed projects', () => {
        expect(results.hasFailure).toBe(false);
    });
    describe('success', () => {
        it('should return true when getting results', () => {
            results.success('proj');
            expect(results.getResult('proj')).toBe(true);
        });
        it('should remove results from file system', () => {
            spyOn(fs, 'writeSync');
            spyOn(fs, 'unlinkSync');
            spyOn(fs, 'existsSync').and.returnValue(true);
            results.success('proj');
            results.saveResults();
            expect(fs.writeSync).not.toHaveBeenCalled();
            expect(fs.unlinkSync).toHaveBeenCalledWith('dist/.nx-results');
        });
        it('should print results', () => {
            const projectName = 'proj';
            results.success(projectName);
            spyOn(output_1.output, 'success');
            const successTitle = 'Success';
            results.printResults(false, successTitle, 'Fail');
            expect(output_1.output.success).toHaveBeenCalledWith({
                title: successTitle
            });
        });
        it('should warn the user that not all tests were run', () => {
            results.startedWithFailedProjects = true;
            const projectName = 'proj';
            spyOn(output_1.output, 'success');
            spyOn(output_1.output, 'warn');
            results.success(projectName);
            const successTitle = 'Success';
            results.printResults(true, successTitle, 'Fail');
            expect(output_1.output.success).toHaveBeenCalledWith({
                title: successTitle
            });
            expect(output_1.output.warn).toHaveBeenCalledWith({
                title: `Only affected projects ${output_1.output.underline('which had previously failed')} were run`,
                bodyLines: [
                    `You should verify by running ${output_1.output.underline('without')} ${output_1.output.bold('--only-failed')}`
                ]
            });
        });
    });
    describe('fail', () => {
        it('should return false when getting results', () => {
            results.fail('proj');
            expect(results.getResult('proj')).toBe(false);
        });
        it('should save results to file system', () => {
            spyOn(fs, 'writeFileSync');
            results.fail('proj');
            results.saveResults();
            expect(fs.writeFileSync).toHaveBeenCalledWith('dist/.nx-results', fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false
                }
            }));
        });
        it('should print results', () => {
            const projectName = 'proj';
            results.fail(projectName);
            spyOn(output_1.output, 'error');
            const errorTitle = 'Fail';
            results.printResults(true, 'Success', errorTitle);
            expect(output_1.output.error).toHaveBeenCalledWith({
                title: errorTitle,
                bodyLines: [
                    output_1.output.colors.gray('Failed projects:'),
                    '',
                    `${output_1.output.colors.gray('-')} ${projectName}`
                ]
            });
        });
        it('should tell the user that they can isolate only the failed tests', () => {
            const projectName = 'proj';
            results.fail(projectName);
            spyOn(output_1.output, 'error');
            const errorTitle = 'Fail';
            results.printResults(false, 'Success', errorTitle);
            expect(output_1.output.error).toHaveBeenCalledWith({
                title: errorTitle,
                bodyLines: [
                    output_1.output.colors.gray('Failed projects:'),
                    '',
                    `${output_1.output.colors.gray('-')} ${projectName}`,
                    '',
                    `${output_1.output.colors.gray('You can isolate the above projects by passing:')} ${output_1.output.bold('--only-failed')}`
                ]
            });
        });
    });
    describe('when results already exist', () => {
        beforeEach(() => {
            spyOn(fs, 'existsSync').and.returnValue(true);
        });
        it('should read existing results', () => {
            spyOn(fs, 'readFileSync').and.returnValue(fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false
                }
            }));
            results = new workspace_results_1.WorkspaceResults('test');
            expect(fs.readFileSync).toHaveBeenCalledWith('dist/.nx-results', 'utf-8');
            expect(results.getResult('proj')).toBe(false);
        });
        it('should handle a corrupted results file', () => {
            spyOn(fs, 'readFileSync').and.returnValue('invalid json');
            const runTests = () => {
                results = new workspace_results_1.WorkspaceResults('test');
            };
            expect(runTests).not.toThrow();
            expect(results.startedWithFailedProjects).toBeFalsy();
        });
        it('should not read the existing results when the previous command was different', () => {
            spyOn(fs, 'readFileSync').and.returnValue(fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false
                }
            }));
            results = new workspace_results_1.WorkspaceResults('build');
            expect(results.getResult('proj')).toBeUndefined();
        });
    });
});
