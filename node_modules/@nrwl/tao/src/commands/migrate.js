"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver_1 = require("semver");
const params_1 = require("../shared/params");
const logger_1 = require("../shared/logger");
const minimist = require("minimist");
const print_help_1 = require("../shared/print-help");
const core_1 = require("@angular-devkit/core");
const node_1 = require("@angular-devkit/core/node");
const tmp_1 = require("tmp");
const fs_1 = require("fs");
const tools_1 = require("@angular-devkit/schematics/tools");
const workflow_1 = require("@angular-devkit/schematics/src/workflow");
const stripJsonComments = require("strip-json-comments");
const path = require("path");
const core = require("@angular-devkit/core/node");
const child_process_1 = require("child_process");
class Migrator {
    constructor(opts) {
        this.versions = opts.versions;
        this.fetch = opts.fetch;
        this.from = opts.from;
        this.to = opts.to;
    }
    updatePackageJson(targetPackage, targetVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageJson = yield this._updatePackageJson(targetPackage, targetVersion, {});
            const migrations = yield this._createMigrateJson(packageJson);
            return { packageJson, migrations };
        });
    }
    _createMigrateJson(versions) {
        return __awaiter(this, void 0, void 0, function* () {
            const migrations = yield Promise.all(Object.keys(versions).map((c) => __awaiter(this, void 0, void 0, function* () {
                const currentVersion = this.versions(c);
                const targetVersion = versions[c];
                if (currentVersion) {
                    const migrationsJson = yield this.fetch(c, targetVersion);
                    if (!migrationsJson.schematics)
                        return [];
                    return Object.keys(migrationsJson.schematics)
                        .filter(r => semver_1.gt(migrationsJson.schematics[r].version, currentVersion) &
                        semver_1.lte(migrationsJson.schematics[r].version, targetVersion))
                        .map(r => (Object.assign({}, migrationsJson.schematics[r], { package: c, name: r })));
                }
                else {
                    return Promise.resolve(null);
                }
            })));
            return migrations.reduce((m, c) => [...m, ...c], []);
        });
    }
    _updatePackageJson(targetPackage, targetVersion, versions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.to[targetPackage]) {
                targetVersion = this.to[targetPackage];
            }
            let currentVersion;
            if (this.from[targetPackage]) {
                currentVersion = this.from[targetPackage];
            }
            else {
                currentVersion = this.versions(targetPackage);
                if (!currentVersion) {
                    throw new Error(`Cannot find package "${targetPackage}" installed.`);
                }
            }
            let migrationsJson;
            try {
                migrationsJson = yield this.fetch(targetPackage, targetVersion);
            }
            catch (e) {
                if (e.message.indexOf('No matching version') > -1) {
                    throw new Error(`${e.message}\nRun migrate with --to="package1@version1,package2@version2"`);
                }
                else {
                    throw e;
                }
            }
            const packages = this.collapsePackages(targetPackage, targetVersion, migrationsJson);
            const childCalls = yield Promise.all(Object.keys(packages)
                .filter(r => !versions[r] || semver_1.gt(packages[r], versions[r]))
                .map(u => this._updatePackageJson(u, packages[u], {
                [targetPackage]: targetVersion
            })));
            return childCalls.reduce((m, c) => {
                Object.keys(c).forEach(r => {
                    if (!m[r] || semver_1.gt(c[r], m[r])) {
                        m[r] = c[r];
                    }
                });
                return m;
            }, { [targetPackage]: migrationsJson.version });
        });
    }
    collapsePackages(packageName, targetVersion, m) {
        if (!m.packageJsonUpdates)
            return {};
        return Object.keys(m.packageJsonUpdates)
            .filter(r => semver_1.gt(m.packageJsonUpdates[r].version, this.versions(packageName)) &
            semver_1.lte(m.packageJsonUpdates[r].version, targetVersion))
            .map(r => m.packageJsonUpdates[r].packages)
            .map(packages => {
            if (!packages)
                return {};
            return Object.keys(packages)
                .filter(p => !packages[p].ifPackageInstalled ||
                this.versions(packages[p].ifPackageInstalled))
                .reduce((m, c) => (Object.assign({}, m, { [c]: packages[c].version })), {});
        })
            .reduce((m, c) => (Object.assign({}, m, c)), {});
    }
}
exports.Migrator = Migrator;
function parseMigrationsOptions(args) {
    const options = params_1.convertToCamelCase(minimist(args, {
        string: ['runMigrations', 'from', 'to'],
        alias: {
            runMigrations: 'run-migrations'
        }
    }));
    if (!options.runMigrations) {
        if (!args[0]) {
            throw new Error(`Specify the package name (e.g., ${print_help_1.commandName} migrate mypackage@1.2.3)`);
        }
        let from = {};
        if (options.from) {
            options.from.split(',').forEach(p => {
                const split = p.lastIndexOf('@');
                from[p.substring(0, split)] = p.substring(split + 1);
            });
        }
        let to = {};
        if (options.to) {
            options.to.split(',').forEach(p => {
                const split = p.lastIndexOf('@');
                to[p.substring(0, split)] = p.substring(split + 1);
            });
        }
        let targetPackage;
        let targetVersion;
        if (args[0].lastIndexOf('@') > 0) {
            const i = args[0].lastIndexOf('@');
            targetPackage = args[0].substring(0, i);
            targetVersion = args[0].substring(i + 1);
        }
        else {
            targetPackage = args[0];
            targetVersion = 'latest';
        }
        return {
            type: 'generateMigrations',
            targetPackage,
            targetVersion,
            from,
            to
        };
    }
    else {
        return { type: 'runMigrations', runMigrations: options.runMigrations };
    }
}
function versions(root) {
    return (packageName) => {
        const content = fs_1.readFileSync(path.join(root, `./node_modules/${packageName}/package.json`));
        if (content) {
            return JSON.parse(stripJsonComments(content.toString()))['version'];
        }
        else {
            return null;
        }
    };
}
// testing-fetch-start
function fetch(packageName, packageVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = tmp_1.dirSync().name;
        child_process_1.execSync(`npm install ${packageName}@${packageVersion} --prefix=${dir}`, {
            stdio: []
        });
        const json = JSON.parse(stripJsonComments(fs_1.readFileSync(path.join(dir, 'node_modules', packageName, 'package.json')).toString()));
        const migrationsFile = json['nx-migrations'] || json['ng-update'];
        if (migrationsFile) {
            const json = JSON.parse(stripJsonComments(fs_1.readFileSync(path.join(dir, 'node_modules', packageName, migrationsFile)).toString()));
            return {
                version: packageVersion,
                schematics: json.schematics,
                packageJsonUpdates: json.packageJsonUpdates
            };
        }
        else {
            return { version: packageVersion };
        }
    });
}
// testing-fetch-end
function createMigrationsFile(root, migrations) {
    fs_1.writeFileSync(path.join(root, 'migrations.json'), JSON.stringify({ migrations }, null, 2));
}
function updatePackageJson(root, packageJson) {
    const packageJsonPath = path.join(root, 'package.json');
    const json = JSON.parse(stripJsonComments(fs_1.readFileSync(packageJsonPath).toString()));
    Object.keys(packageJson).forEach(p => {
        if (json.devDependencies && json.devDependencies[p]) {
            json.devDependencies[p] = packageJson[p];
        }
        else {
            if (!json.dependencies)
                json.dependencies = {};
            json.dependencies[p] = packageJson[p];
        }
    });
    fs_1.writeFileSync(packageJsonPath, JSON.stringify(json, null, 2));
}
function generateMigrationsJsonAndUpdatePackageJson(logger, root, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const migrator = new Migrator({
            versions: versions(root),
            fetch,
            from: opts.from,
            to: opts.to
        });
        const { migrations, packageJson } = yield migrator.updatePackageJson(opts.targetPackage, opts.targetVersion);
        createMigrationsFile(root, migrations);
        updatePackageJson(root, packageJson);
        logger.info(`The migrate command has run successfully.`);
        logger.info(`- package.json has been updated`);
        logger.info(`- migrations.json has been generated`);
        logger.info(`Next steps:`);
        logger.info(`- Make sure package.json changes make sense and then run 'npm install' or 'yarn'`);
        logger.info(`- Run 'nx migrate --run-migrations=migrations.json'`);
    });
}
class MigrationEngineHost extends tools_1.NodeModulesEngineHost {
    constructor() {
        super();
    }
    _resolveCollectionPath(name) {
        let collectionPath = undefined;
        if (name.replace(/\\/g, '/').split('/').length > (name[0] == '@' ? 2 : 1)) {
            try {
                collectionPath = this._resolvePath(name, process.cwd());
            }
            catch (_a) { }
        }
        if (!collectionPath) {
            let packageJsonPath = this._resolvePackageJson(name, process.cwd());
            if (!core.fs.isFile(packageJsonPath)) {
                packageJsonPath = path.join(packageJsonPath, 'package.json');
            }
            let pkgJsonSchematics = require(packageJsonPath)['nx-migrations'];
            if (!pkgJsonSchematics || typeof pkgJsonSchematics != 'string') {
                pkgJsonSchematics = require(packageJsonPath)['ng-update'];
                if (!pkgJsonSchematics) {
                    throw new Error(`Could find migrations in package: "${name}"`);
                }
            }
            collectionPath = this._resolvePath(pkgJsonSchematics, path.dirname(packageJsonPath));
        }
        try {
            if (collectionPath) {
                JSON.parse(stripJsonComments(fs_1.readFileSync(collectionPath).toString()));
                return collectionPath;
            }
        }
        catch (e) {
            throw new Error(`Invalid migration file in package: "${name}"`);
        }
        throw new Error(`Collection cannot be resolved: "${name}"`);
    }
}
class MigrationsWorkflow extends workflow_1.BaseWorkflow {
    constructor(host) {
        super({
            host,
            engineHost: new MigrationEngineHost(),
            force: true,
            dryRun: false
        });
    }
}
function runMigrations(logger, root, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const migrationsFile = JSON.parse(stripJsonComments(fs_1.readFileSync(path.join(root, opts.runMigrations)).toString()));
        const host = new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), core_1.normalize(root));
        const workflow = new MigrationsWorkflow(host);
        let p = Promise.resolve(null);
        migrationsFile.migrations.forEach(m => {
            logger.info(`Running migration ${m.package}:${m.name}`);
            p = p.then(() => {
                return workflow
                    .execute({
                    collection: m.package,
                    schematic: m.name,
                    options: {},
                    debug: false,
                    logger
                })
                    .toPromise()
                    .then(() => {
                    logger.info(`Successfully finished ${m.package}:${m.name}`);
                    logger.info(`---------------------------------------------------------`);
                });
            });
        });
        yield p;
    });
}
function migrate(root, args) {
    return __awaiter(this, void 0, void 0, function* () {
        return params_1.handleErrors(logger_1.logger, () => __awaiter(this, void 0, void 0, function* () {
            const opts = parseMigrationsOptions(args);
            if (opts.type === 'generateMigrations') {
                yield generateMigrationsJsonAndUpdatePackageJson(logger_1.logger, root, opts);
            }
            else {
                yield runMigrations(logger_1.logger, root, opts);
            }
        }));
    });
}
exports.migrate = migrate;
