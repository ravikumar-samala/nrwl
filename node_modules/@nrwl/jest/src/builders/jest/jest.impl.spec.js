"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// import JestBuilder from './jest.impl';
const core_1 = require("@angular-devkit/core");
const testing_1 = require("@angular-devkit/architect/testing");
jest.mock('jest');
const { runCLI } = require('jest');
const path = require("path");
const architect_1 = require("@angular-devkit/architect");
describe('Jest Builder', () => {
    let architect;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const testArchitectHost = new testing_1.TestingArchitectHost('/root', '/root');
        architect = new architect_1.Architect(testArchitectHost, registry);
        yield testArchitectHost.addBuilderFromPackage(path.join(__dirname, '../../..'));
        runCLI.mockReturnValue(Promise.resolve({
            results: {
                success: true
            }
        }));
    }));
    it('should send appropriate options to jestCLI', () => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            watch: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        expect(runCLI).toHaveBeenCalledWith({
            _: [],
            globals: JSON.stringify({
                'ts-jest': {
                    tsConfig: '/root/tsconfig.test.json',
                    diagnostics: {
                        warnOnly: true
                    },
                    stringifyContentPathRegex: '\\.html$',
                    astTransformers: [
                        'jest-preset-angular/InlineHtmlStripStylesTransformer'
                    ]
                }
            }),
            watch: false
        }, ['/root/jest.config.js']);
    }));
    it('should send appropriate options to jestCLI when testFile is specified', () => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            testFile: 'lib.spec.ts',
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            codeCoverage: false,
            runInBand: true,
            testNamePattern: 'should load',
            testPathPattern: '/test/path',
            colors: false,
            reporters: ['/test/path'],
            verbose: false,
            coverage: false,
            coverageReporters: 'test',
            coverageDirectory: '/test/path',
            watch: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        expect(runCLI).toHaveBeenCalledWith({
            _: ['lib.spec.ts'],
            globals: JSON.stringify({
                'ts-jest': {
                    tsConfig: '/root/tsconfig.test.json',
                    diagnostics: {
                        warnOnly: true
                    },
                    stringifyContentPathRegex: '\\.html$',
                    astTransformers: [
                        'jest-preset-angular/InlineHtmlStripStylesTransformer'
                    ]
                }
            }),
            coverage: false,
            runInBand: true,
            testNamePattern: 'should load',
            testPathPattern: '/test/path',
            colors: false,
            reporters: ['/test/path'],
            verbose: false,
            coverageReporters: 'test',
            coverageDirectory: '/test/path',
            watch: false
        }, ['/root/jest.config.js']);
    }));
    it('should send appropriate options to jestCLI when findRelatedTests is specified', () => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            findRelatedTests: 'file1.ts,file2.ts',
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            codeCoverage: false,
            runInBand: true,
            testNamePattern: 'should load',
            watch: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        expect(runCLI).toHaveBeenCalledWith({
            _: ['file1.ts', 'file2.ts'],
            globals: JSON.stringify({
                'ts-jest': {
                    tsConfig: '/root/tsconfig.test.json',
                    diagnostics: {
                        warnOnly: true
                    },
                    stringifyContentPathRegex: '\\.html$',
                    astTransformers: [
                        'jest-preset-angular/InlineHtmlStripStylesTransformer'
                    ]
                }
            }),
            coverage: false,
            findRelatedTests: true,
            runInBand: true,
            testNamePattern: 'should load',
            watch: false
        }, ['/root/jest.config.js']);
    }));
    it('should send other options to jestCLI', () => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            codeCoverage: true,
            bail: 1,
            color: false,
            ci: true,
            json: true,
            maxWorkers: 2,
            onlyChanged: true,
            outputFile: 'abc.txt',
            passWithNoTests: true,
            silent: true,
            testNamePattern: 'test',
            testPathPattern: '/test/path',
            colors: false,
            reporters: ['/test/path'],
            verbose: false,
            coverage: false,
            coverageReporters: 'test',
            coverageDirectory: '/test/path',
            updateSnapshot: true,
            useStderr: true,
            watch: false,
            watchAll: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        expect(runCLI).toHaveBeenCalledWith({
            _: [],
            globals: JSON.stringify({
                'ts-jest': {
                    tsConfig: '/root/tsconfig.test.json',
                    diagnostics: {
                        warnOnly: true
                    },
                    stringifyContentPathRegex: '\\.html$',
                    astTransformers: [
                        'jest-preset-angular/InlineHtmlStripStylesTransformer'
                    ]
                }
            }),
            coverage: true,
            bail: 1,
            color: false,
            ci: true,
            json: true,
            maxWorkers: 2,
            onlyChanged: true,
            outputFile: 'abc.txt',
            passWithNoTests: true,
            silent: true,
            testNamePattern: 'test',
            testPathPattern: '/test/path',
            colors: false,
            verbose: false,
            reporters: ['/test/path'],
            coverageReporters: 'test',
            coverageDirectory: '/test/path',
            updateSnapshot: true,
            useStderr: true,
            watch: false,
            watchAll: false
        }, ['/root/jest.config.js']);
    }));
    it('should send the main to runCLI', () => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            setupFile: './test.ts',
            watch: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        expect(runCLI).toHaveBeenCalledWith({
            _: [],
            globals: JSON.stringify({
                'ts-jest': {
                    tsConfig: '/root/tsconfig.test.json',
                    diagnostics: {
                        warnOnly: true
                    },
                    stringifyContentPathRegex: '\\.html$',
                    astTransformers: [
                        'jest-preset-angular/InlineHtmlStripStylesTransformer'
                    ]
                }
            }),
            setupTestFrameworkScriptFile: '/root/test.ts',
            watch: false
        }, ['/root/jest.config.js']);
    }));
    it('should return the proper result', (done) => __awaiter(this, void 0, void 0, function* () {
        const run = yield architect.scheduleBuilder('@nrwl/jest:jest', {
            jestConfig: './jest.config.js',
            tsConfig: './tsconfig.test.json',
            watch: false
        });
        expect(yield run.result).toEqual(jasmine.objectContaining({
            success: true
        }));
        done();
    }));
});
