"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const path = require("path");
try {
    require('dotenv').config();
}
catch (e) { }
const { runCLI } = require('jest');
exports.default = architect_1.createBuilder(run);
function run(options, context) {
    options.jestConfig = path.resolve(context.workspaceRoot, options.jestConfig);
    const tsJestConfig = {
        tsConfig: path.resolve(context.workspaceRoot, options.tsConfig),
        // Typechecking wasn't done in Jest 23 but is done in 24. This makes errors a warning to amend the breaking change for now
        // Remove for v8 to fail on type checking failure
        diagnostics: {
            warnOnly: true
        }
    };
    // TODO: This is hacky, We should probably just configure it in the user's workspace
    // If jest-preset-angular is installed, apply settings
    try {
        require.resolve('jest-preset-angular');
        Object.assign(tsJestConfig, {
            stringifyContentPathRegex: '\\.html$',
            astTransformers: ['jest-preset-angular/InlineHtmlStripStylesTransformer']
        });
    }
    catch (e) { }
    const config = {
        _: [],
        config: options.config,
        coverage: options.codeCoverage,
        bail: options.bail,
        ci: options.ci,
        color: options.color,
        json: options.json,
        maxWorkers: options.maxWorkers,
        onlyChanged: options.onlyChanged,
        outputFile: options.outputFile,
        passWithNoTests: options.passWithNoTests,
        runInBand: options.runInBand,
        silent: options.silent,
        testNamePattern: options.testNamePattern,
        testPathPattern: options.testPathPattern,
        colors: options.colors,
        verbose: options.verbose,
        coverageReporters: options.coverageReporters,
        coverageDirectory: options.coverageDirectory,
        updateSnapshot: options.updateSnapshot,
        useStderr: options.useStderr,
        watch: options.watch,
        watchAll: options.watchAll,
        globals: JSON.stringify({
            'ts-jest': tsJestConfig
        })
    };
    if (options.setupFile) {
        config.setupTestFrameworkScriptFile = path.resolve(context.workspaceRoot, options.setupFile);
    }
    if (options.testFile) {
        config._.push(options.testFile);
    }
    if (options.findRelatedTests) {
        const parsedTests = options.findRelatedTests.split(',').map(s => s.trim());
        config._.push(...parsedTests);
        config.findRelatedTests = true;
    }
    if (options.clearCache) {
        config.clearCache = true;
    }
    if (options.reporters && options.reporters.length > 0) {
        config.reporters = options.reporters;
    }
    return rxjs_1.from(runCLI(config, [options.jestConfig])).pipe(operators_1.map((results) => {
        return {
            success: results.results.success
        };
    }));
}
