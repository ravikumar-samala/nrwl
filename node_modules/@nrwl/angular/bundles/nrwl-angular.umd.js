(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngrx/effects'), require('@ngrx/router-store'), require('@ngrx/store'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@nrwl/angular', ['exports', '@angular/core', '@ngrx/effects', '@ngrx/router-store', '@ngrx/store', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.nrwl = global.nrwl || {}, global.nrwl.angular = {}), global.ng.core, global.ngrx.effects, global.ngrx.routerStore, global.ngrx.store, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, effects, routerStore, store, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function pessimisticUpdate(opts) {
        return function (source) {
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    function optimisticUpdate(opts) {
        return function (source) {
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
        };
    }
    function fetch(opts) {
        return function (source) {
            if (opts.id) {
                var groupedFetches = source.pipe(mapActionAndState(), operators.groupBy(function (_a) {
                    var _b = __read(_a, 2), action = _b[0], store = _b[1];
                    return opts.id(action, store);
                }));
                return groupedFetches.pipe(operators.mergeMap(function (pairs) {
                    return pairs.pipe(operators.switchMap(runWithErrorHandling(opts.run, opts.onError)));
                }));
            }
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    function navigation(component, opts) {
        return function (source) {
            var nav = source.pipe(mapActionAndState(), operators.filter(function (_a) {
                var _b = __read(_a, 2), action = _b[0], state = _b[1];
                return isStateSnapshot(action);
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), action = _b[0], state = _b[1];
                if (!isStateSnapshot(action)) {
                    // Because of the above filter we'll never get here,
                    // but this properly type narrows `action`
                    return;
                }
                return [
                    findSnapshot(component, action.payload.routerState.root),
                    state
                ];
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), snapshot = _b[0], state = _b[1];
                return !!snapshot;
            }));
            return nav.pipe(operators.switchMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    function isStateSnapshot(action) {
        return action.type === routerStore.ROUTER_NAVIGATION;
    }
    function runWithErrorHandling(run, onError) {
        return function (_a) {
            var _b = __read(_a, 2), action = _b[0], state = _b[1];
            try {
                var r = wrapIntoObservable(run(action, state));
                return r.pipe(operators.catchError(function (e) { return wrapIntoObservable(onError(action, e)); }));
            }
            catch (e) {
                return wrapIntoObservable(onError(action, e));
            }
        };
    }
    /**
     * @whatItDoes maps Observable<Action | [Action, State]> to
     * Observable<[Action, State]>
     */
    function mapActionAndState() {
        return function (source) {
            return source.pipe(operators.map(function (value) {
                var _a = __read(normalizeActionAndState(value), 2), action = _a[0], store = _a[1];
                return [action, store];
            }));
        };
    }
    /**
     * @whatItDoes Normalizes either a bare action or an array of action and state
     * into an array of action and state (or undefined)
     */
    function normalizeActionAndState(args) {
        var _a;
        var action, state;
        if (args instanceof Array) {
            _a = __read(args, 2), action = _a[0], state = _a[1];
        }
        else {
            action = args;
        }
        return [action, state];
    }
    /**
     * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
     */
    var DataPersistence = /** @class */ (function () {
        function DataPersistence(store, actions) {
            this.store = store;
            this.actions = actions;
        }
        /**
         *
         * @whatItDoes Handles pessimistic updates (updating the server first).
         *
         * Update the server implemented naively suffers from race conditions and poor error handling.
         *
         * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run(a, state) {
         *       // update the backend first, and then dispatch an action that will
         *       // update the client side
         *       return this.backend(state.user, a.payload).map(updated => ({
         *         type: 'TODO_UPDATED',
         *         payload: updated
         *       }));
         *     },
         *
         *     onError(a, e: any) {
         *       // we don't need to undo the changes on the client side.
         *       // we can dispatch an error, or simply log the error here and return `null`
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         *   @Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         */
        DataPersistence.prototype.pessimisticUpdate = function (actionType, opts) {
            return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), pessimisticUpdate(opts));
        };
        /**
         *
         * @whatItDoes Handles optimistic updates (updating the client first).
         *
         * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
         * the developer already updated the state locally, so the developer must provide an undo action.
         *
         * The error handling must be done in the callback, or by means of the undo action.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload);
         *     },
         *
         *     undoAction: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return ({
         *         type: 'UNDO_UPDATE_TODO',
         *         payload: a
         *       });
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         *   @Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         */
        DataPersistence.prototype.optimisticUpdate = function (actionType, opts) {
            return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), optimisticUpdate(opts));
        };
        /**
         *
         * @whatItDoes Handles data fetching.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODOS',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * This is correct, but because it set the concurrency to 1, it may not be performant.
         *
         * To fix that, you can provide the `id` function, like this:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
         *     id: (a, state) => {
         *       return a.payload.id;
         *     }
         *
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODO',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
         *
         * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
         * it will only run the last one.
         */
        DataPersistence.prototype.fetch = function (actionType, opts) {
            return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), fetch(opts));
        };
        /**
         * @whatItDoes Handles data fetching as part of router navigation.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `navigation` addresses these problems.
         *
         * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
         * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
         * the last request.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
         *     run: (a, state) => {
         *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
         *         type: 'TODO_LOADED',
         *         payload: todo
         *       }));
         *     },
         *     onError: (a, e: any) => {
         *       // we can log and error here and return null
         *       // we can also navigate back
         *       return null;
         *     }
         *   });
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         */
        DataPersistence.prototype.navigation = function (component, opts) {
            return this.actions.pipe(operators.withLatestFrom(this.store), navigation(component, opts));
        };
        DataPersistence = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [store.Store, effects.Actions])
        ], DataPersistence);
        return DataPersistence;
    }());
    function findSnapshot(component, s) {
        var e_1, _a;
        if (s.routeConfig && s.routeConfig.component === component) {
            return s;
        }
        try {
            for (var _b = __values(s.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var c = _c.value;
                var ss = findSnapshot(component, c);
                if (ss) {
                    return ss;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    }
    function wrapIntoObservable(obj) {
        if (!!obj && obj instanceof rxjs.Observable) {
            return obj;
        }
        else if (!obj) {
            return rxjs.of();
        }
        else {
            return rxjs.of(obj);
        }
    }

    /**
     * @whatItDoes Provides services for enterprise Angular applications.
     *
     * See {@link DataPersistence} for more information.
     */
    var NxModule = /** @class */ (function () {
        function NxModule() {
        }
        NxModule_1 = NxModule;
        NxModule.forRoot = function () {
            return { ngModule: NxModule_1, providers: [DataPersistence] };
        };
        var NxModule_1;
        NxModule = NxModule_1 = __decorate([
            core.NgModule({})
        ], NxModule);
        return NxModule;
    }());

    exports.DataPersistence = DataPersistence;
    exports.NxModule = NxModule;
    exports.fetch = fetch;
    exports.navigation = navigation;
    exports.optimisticUpdate = optimisticUpdate;
    exports.pessimisticUpdate = pessimisticUpdate;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=nrwl-angular.umd.js.map
